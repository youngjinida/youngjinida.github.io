---
title:  "학습 관련 기술들" 

categories:
  - Basic
tags:
  - [Programming, Python]

toc: true
toc_sticky: true

date: 2022-04-07
last_modified_at: 2022-04-07
---

밑바닥부터 시작하는 딥러닝 책을 공부한 내용을 토대로 작성한 글입니다.

<br>

# Chapter 4. 학습 관련 기술

전 글에서는 오차 역전파에 대한 이론과 더불어 구현함으로써 신겸망을 학습시켜보았다. 이번 글에서는 학습되는 가중치 매개변수의 최적값을 탐색하는 방법과 가중치 매개변수의 초깃값 설정 및 하이퍼파라미터의 설정 방법, 오버피팅의 대응책인 가중치 감소와 드롭아웃, 배치정규화등에 대해서 다룰 생각이다. 

## 4.1 최적화

신경망 학습시키는 지표는 손실 함수의 값을 가능한 한 낮추는 매개변수를 찾는 것이다. 이는 곧 매개변수의 최적값을 찾는 문제이며 이러한 문제를 푸는 것을 최적화라고 한다. 매개변수 공간은 매우 넓고 복잡해서 최적의 값을 찾는 것은 매우 어려운 문제이다. 지금까지의 방법으로는 매개변수의 기울기를 구해 기울어진 방향으로 매개변수 값을 갱신하는 일을 몇번이고 반복해서 점점 최적의 값에 다가가는 방법인 확률적 경사 하강법(SGD)를 사용하였다. SGD도 문제에 따라서는 좋은 방법이 될 수 있지만 SGD로 해결이 되지않는 문제를 풀기위해서 SGD와는 다른 최적화 기법을 소개한다.

### SGD

우선 다른 최적화 기법을 소개하기 전 먼저 SGD를 복습해보자 수식으로는 다음과 같이 쓸 수 있다.

$$ W = W - \lambda \frac{dL}{dW} $$

여기에서 $W$
는 갱신할 가중치 매개변수를 말하며
$\frac{dL}{dW}$
는 $W$
에 대한 손실 함수의 기울기를 말한다. 또한
$\lambda$
는 학습률을 의미한다. 식에서 보면 알 수 있듯이 SGD는 기울진 방향으로 일정 거리만 가겠다는 단순한 방법이다. 이를 파이썬으로 구현하면 아래와같다.

```python
class SGD:
    def __init__(self, lr = 0.01):
        self.lr = lr

    def update(self, params, grads):
        for key in params.keys():
            params[key] -= self.lr * grads[key]
```

이러한 SGD는 직관적이며 구현도 쉽게 할 수 있지만, 문제에 따라서는 비효율적일 때가 있다. SGD를 토아혀 아래 함수의 최소값을 구하는 문제를 생각해보자

$$
f(x,y) = \frac{1}{20}x^2 + y^2
$$

이 함수는 기울기는 아래의 모양과 같다.

![img4-1](/assets/images/badak/fig%206-2.png)

이 기울기는 y축 방향은 크고 x축 방향은 작다는 것이 특징이다. 또한 함수
$f(x,y)$
의 최솟값이 되는 장소는 (0, 0)임에도 불구하고 그림에서 보여주는 기울기의 대부분은 (0, 0)을 가르키지 않는 다는 것이다. 또한 이 함수에 SGD를 적용한 결과는 아래와 같다.

![img4-2](/assets/images/badak/fig%206-3.png)

SGD는 위와 같이 심하게 굽이진 움직임을 보이며 상당히 비효율적인 움직임인 것을 알 수 있으며 SGD가 지그재그로 탐색하는 근본 원인은 기울어진 방향이 본래의 최솟값과 다른 방향을 가리키기 때문이다. 즉, SGD의 단점은 비등방성 함수에서는 탐색경로가 비효율적이라는 것이다. 

비등방성 함수 - 비등방성이란 방향에 따라서 물리적 <u>성질</u>이 바뀌는 것을 의미함. 비등방성 함수는 앞에 언급한 성질이 기울기의 성질이라고 생각하면 된다. 즉, 비등방성 함수는 특정한 지점(좌표)에서 기울기의 성질이 변하는 함수를 말한다.

### Momentum

<u>Momentum</u>은 '운동량'을 뜻하는 단어로, 물리와 관계가 있다. 모멘텀 기법은 수식으로는 다음과 같이 쓸 수 있다.

$$
v = \alpha v - \gamma \frac{dL}{dW}
$$

$$
W = W + v
$$

SGD와 같이 여기에서도 
$W$
는 가중치 매개변수,
$\frac{dL}{dW}$
는 $W$
에 대한 손실 함수의 기울기
$\gamma$
는 학습률을 뜻한다. 
하지만 여기서
$v$
라는 새로운 변수가 나오는데, 이는 물리에서 말하는 속도에 해당한다. 위 식을 풀이하자면 기울기 방향으로 힘을 받아 물체가 가속된다는 물리법칙을 나타낸며 또, 식의
$\alpha$ 
항은 물체가 아무런 힘을 받지 않을 때 서서히 하강시키는 역할을 한다. 물리에서의 마찰이나 공기 저항에 해당한다고 생각하면 된다. 이를 구현하면 아래와 같다.

```python
class Momentum:
    def __init__(self, lr = 0.01, momentum = 0.9):
        self.lr = lr
        self.momentum = 0.9
        self.v = None
    
    def update(self, param, grads):
        if self.v is None:
            self.v = {}
            for key, val in param.items():
                self.v[key] = np.zeros_like(val)
        
        for key in param.keys():
            self.v[key] = self.momentum * self.v[key] - self.lr * grads[key]
            param[key] += self.v[key]
```

이제 모멘텀을 통해 최적화 문제를 풀 경우 결과는 다음과 같다.

![img4-3](/assets/images/badak/fig%206-5.png)

확실히 SGD와 비교하였을 때 지그재그의 정도가 덜한 것을 확인할 수 있고 이는 x축의 힘이 아주 작지만 방향은 변하지 않아서 한 방향으로 일정하게 가속하기 때문이다. 거꾸로 y축의 힘은 크지만 위아래로 번갈아받아서 상충하여 y축의 방향의 속도는 안정적이지 않은 것을 확인할 수 있다.

### Adagrad

신경망 학습에서는 학습률 값이 중요하다. 이 값이 너무 작으면 학습 시간이 너무 길어지고, 반대로 너무 크면 발산하여 학습이 제대로 이뤄지지 않는다. 이 학습률을 정하는 효과적 기술로 <u>학습률 감소</u>가 있다. 이는 학습을 진행하면서 학습률을 줄여가는 방법이다. 처음에는 크게 학습하다가 조금씩 작게 학습한다는 얘기로, 실제 신경망 학습에 자주 쓰인다.

학습률을 서서히 낮추는 가장 간단한 방법은 매개변수 전체의 학습률을 일괄적으로 낮추는 것이다. 하지만 이를 더욱 발전시킨 것이 AdaGrad이다. AdaGrad는 매개변수 각각에 맞는 맞춤형 학습률을 만들어준다.

AdaGrad의 갱신 방법은 수식으로는 다음과 같다.

$$
h = h + \frac{dL}{dW} \cdot \frac{dL}{dW}
$$

$$
W = W - \gamma \frac{1}{\sqrt{h}} \frac{dL}{dW}
$$

여기에서 새로
$h$
라는 변수가 등장하는데
$h$
는 식에서 보듯 기존 기울기 값을 제곱하여 계속 더해준다.(여기서 
$\cdot$
기호는 행렬의 원소곱을 뜻한다.) 그리고 매개변수를 갱신할 때
$\frac{1}{\sqrt{h}}$
를 곱하여 학습률을 조정한다. 매개변수의 원소 중에서 많이 움직인 원소는 학습률이 낮아진다는 뜻이며 다시 말해 학습률 감소가 매개변수의 원소마다 다르게 적용됨을 뜻한다.

그럼 AdaGrad의 구현을 살펴보자.

```python
class AdaGrad:
    def __init__(self, lr = 0.01):
        self.lr = lr
        self.h = None

    def update(self, params, grads):
        if self.h is None:
            self.h = {}
            for key, val in params.items():
                self.h[key] = np.zeros_like(val)
        
        for key in params.keys():
            self.h[key] += grads[key] * grads[key]
            params[key] -= self.lr * grads[key] / (np.sqrt(self.h[key]) + 1e-7)
            # 1e-7을 더해줌으로써 divide by zero 문제를 해결한다.
```

이제 AdaGrad를 사용해서 최적화 문제를 풀어보자

![img4-4](/assets/images/badak/fig%206-6.png)


그림을보면 최솟값을 향해 효율적으로 움직이는 것을 알 수 있다. y축 방향은 기울기가 커서 처음에는 크게 움직이지만, 그 큰 움직임에 비례해 갱신 정도도 큰 폭으로 작아지도록 조정된다. 그래서 y축 방향으로의 갱신 강도가 빠르게 약해지고 지그재그 움직임이 줄어듦을 알 수 있다.

### RMSProp

위의 AdaGrad는 과거의 기울기를 제곱하여 계속더해간다. 그래서 학습을 진행할수록 갱신 강도가 약해지게된다. 실제로 무한히 계속학습한다면 어느 순간 갱신량이 0이 되어 전혀 갱신되지 않게 되는데 이문제를 개선한 기법으로서 RMSProp이라는 방법이 있다. RMSProp은 과거의 모든 기울기를 균일하게 더해가는 것이 아닌, 먼 과거의 기울기는 서서히 잊고 새로운 기울기 정보를 크게 반영한다. 이를 지수이동평균이라 하여 과거 기울기의 반영 규모를 기하급수적으로 감소시킨다. 수식으로 표현하면 다음과 같다.

$$
h = \alpha h + (1-\alpha)(\frac{dL}{dW})^2
$$

$$
W = W - \gamma \frac{1}{\sqrt{h+\epsilon}} \frac{dL}{dW}
$$

위 변수들은 대부분 위에서 사용된 것들과 같으며 변경된 사항인
$\alpha$
의 경우 예전의 값을 
$\alpha$
만큼 참조하고 새로운 가중치에 대해서는
$(1-\alpha)$
만큼 참조를 하여 갱신을 하기위해 사용하는 변수이다. 또한
$\epsilon$
은 Devide by 0 문제를 해결하기 위해 사용되는 변수이다. 파이썬으로 하는 구현은 아래와 같다.

```python
class RMSProp:
    def __init__(self, lr = 0.01, p = 0.99):
        self.lr = lr
        self.p = p
        self.h = None
    
    def update(self, params, grads):
        if self.h is None:
            self.h = {}
            for key, val in params.items():
                self.h[key] = np.zeros_like(val)
        
        for key in params.keys():
            self.h[key] = self.p * self.h[key] + (grads[key] * grads[key] * (1 - self.p))
            params[key] -= self.lr * grads[key] / (np.sqrt(self.h[key]) + 1e-7)
```

구현하여 실행시킨 결과는 아래와 같은데 AdaGrad와 같이 최솟값을 향해 효율적으로 움직이며 갱신의 횟수가 많지 않기때문에 AdaGrad와 비슷한 움직임을 보인다.

![img4-4](/assets/images/badak/rmsprop-gray.png)


### Adam

Momentum은 공이 그릇 바닥을 구르는 듯한 움직임을 보였다. AdaGrad는 매개변수의 원소마다 적응적으로 갱신 정도를 조정했다. 이 두 기법을 활용하여 만든 기법이 Adam이다.

Adam은 2015년에 제안된 새로운 방법이며 그 이론은 다소 복잡하지만 직관적으로는 Momentum과 AdaGrad를 융합한듯한 방법이다.

