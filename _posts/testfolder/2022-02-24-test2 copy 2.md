---
title:  "딥러닝 신경망 이론 및 구현" 

categories:
  - Basic
tags:
  - [Programming, Python]

toc: true
toc_sticky: true

date: 2022-03-28
last_modified_at: 2022-03-28
---

밑바닥부터 시작하는 딥러닝 책을 공부한 내용을 토대로 작성한 글입니다.

<br>

# Chapter 1. 딥러닝 신경망 이론 및 구현
## 1.1 퍼셉트론이란?

<u>퍼셉트론</u>은 다수의 신호를 입력으로 받아 하나의 신호를 출력한다. 여기서 말하는 신호랑 전류나 강물처럼 흐름이 있는 것을 상상하면 좋다. 전류가 전선을 타고 흐르는 전자를 내보내듯, 퍼셉트론 신호도 흐름을 만들고 정보를 앞으로 전달한다. 

## 1.2 퍼셉트론의 한계
위에서 서술한 퍼셉트론으로는 복잡한 함수도 표현할 수 있으며 그 예로 컴퓨터가 수행하는 복잡한 처리도 퍼셉트론으로 표현할 수 있다고 한다. 하지만 퍼셉트론을 이루는 가중치를 설정하는 작업은 여전히 사람의 수작업을 통해서 진행된다. 

## 1.3 신경망
위 퍼셉트론의 한계를 벗어나는 해결책으로 우리는 신경망을 사용한다. 신경망은 퍼셉트론과 달리 가중치 매개변수의 적절한 값을 데이터로부터 자동으로 학습하는 능력을 가진다.

### 신경망의 예
<center>

![img3-1](../../img/badak/fig%203-1.png)

</center>

위 신경망은 모두 3층으로 구성이되지만 가중치를 갖는 층은 2개뿐이기 때문에 <u>2층 신경망</u>이라고 한다.

## 1.4 활성화 함수
활성화 함수란 이름과 같이 입력신호의 총합이 활성화를 일으키는지를 정하는 역할을 한다. 가중치가 달린 입력신호와 편항의 총합을 계산하고 이를 a라고 한다. 그리고 a를 활성화 함수 h를 통하여 y를 출력하는 흐름이며 예는 아래와 같다.

<center>

$a = b + w_1x_1 + w_1x_1$

$y = h(a)$

![img3-2](../../img/badak/fig%203-4.png)

</center>

또한 보통의 퍼셉트론에서는 계단 함수를 활성화 함수로 채용하는데 신경망에서는 계단 함수가 아닌 다른 활성 함수를 사용한다. 보통의 신경망에서 쉽게 사용가능한 활성함수로써 Sigmoid와 Relu를 소개한다.

### Step function

<center>

$h(x)=
\begin{cases}
1,\;if\;x>0\\
0,\;else
\end{cases}$

![img3-3](../../img/badak/fig%203-6.png)

</center>

### Sigmoid

<center>

$
h(x) = \frac{1}{1 + exp(-x)}
$


![img3-4](../../img/badak/fig%203-7.png)

</center>

### Relu

<center>

$h(x)=
\begin{cases}
x,\;if\;x>0\\
0,\;else
\end{cases}$

![img3-5](../../img/badak/fig%203-9.png)

</center>

위 함수들을 보았을 때 공통적인 성질은 <u>비선형 함수</u>라는 것이다. 신경망에서는 활성화 함수로 선형 함수를 사용해서는 안되기 때문이다. 그 이유로는 선형 함수를 사용하여 은닉층을 늘려도 은닉층이 없는 네트워크와 똑같은 기능을 할 수 있다는 데에 있다. 간단한 예를들어 설명하자면 h(x) = cx 라는 활성 함수를 사용하고 3층짜리 신경망을 설계한다면 y = h(h(h(x))) 이며 값은 y = c^3x가 나올 것이고 y = ax, a=c^3 이와 같이 1층 짜리 신경망으로도 구현할 수 있다. 그러므로 층을 쌓으므로써 혜택을 얻고싶다면 활성함수로는 비선형 함수를 사용하여야 한다.

***Activation_Func.py***
```python
import numpy as np

def step_function(x):
	y = x > 0
	return y.astype(np.int)

def sigmoid(x):
	return 1 / (1 + np.exp(-x))

def Relu(x):
	return np.maximum(0, x)
```

## 1.5 출력층 설계
신경망은 분류와 회귀 모두에 이용할 수 있다. 다만 둘 중 어떤 문제냐에 따라 출력층에서 사용하는 활성화 함수가 달라지게 되고 일반적으로는 회귀 문제에서는 항등 함수를, 분류에서는 소프트맥스 함수를 사용한다.

### 항등 함수
항등 함수는 입력을 그대로 출력한다. 입력과 출력이 항상 같다는 뜻의 항등이며 출력층에서 항등 함수를 사용한다면 입력 신호가 그대로 출력 신호가 된다.

### 소프트맥스

$$
y_k = \frac{exp(a_k)}{\sum_{i=1}^{n} a_i}
$$

위의 수식과 같이 소프트맥스는 분자가 입력 신호 $a_k$의 지수함수, 분모는 모든 입력신호의 지수 함수의 함으로 구성이된다. 또한 소프트맥스 출력의 총합은 1이다. 출력의 총합이 1이 된다는 것은 소프트 맥스 함수의 중요한 성질이며 이러한 성질로 인해 소프트맥스 함수의 출력을 <u>확률</u>로써 해석할 수 있게된다.

***Out_Func.py***
```python
import numpy as np

def identity_func(x):
	return x

def softmax(x):
	c = np.max(x)
	exp_x = np.exp(x - c)
	sum_exp_x = np.sum(exp_x)
	y = exp_x / sum_exp_x

	return y

```

***📃Game2D.h***
```cpp
#include "RGB.h"           // 색을 결정. R,G,B 값을 받는 생성자 有 
#include "Vector2.h"       // 2차원 좌표
#include "Vector3.h"       // 3차원 좌표
#include "Colors.h"        
// 👆 RGB를 include하여 다양한 색상 이름의 RGB 객체들을 미리 정의해 둠. const RGB yellow(255, 255, 0) 이런식으로.
#include "Timer.h"
#include "DrawFunctions.h" 
// 👆 원, 세모, 네모, 선분 등등 그림을 그리는 함수들을 모은 클래스. drawWLine, drawFilledBox 등등..

#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <thread>         // std::this_thread::sleep_for
#include <iostream>
#include <vector>
#include <string>
#include <map>

namespace jm
{
	using vec2 = Vector2<float>;
	using vec3 = Vector3<float>;

	class Game2D
	{
	private:
		
		/*게임 창 해상도*/ 
		int width = 640; 
		int height = 480;

		/*게임 창 화면의 포인터*/
		GLFWwindow* glfw_window = nullptr;

		Timer timer;

		/*fps (프레임)의 역수*/
		float spf = 1.0f / 60.0f;		 // second(s) per frame

		/*키보드 입력을 받아서 그릴거냐(true) 말거냐(false) */
		std::map<int, bool> key_status;  // key_id, is_pressed
		std::map<int, bool> mbtn_status; // mouse_button_id, is_pressed
		bool draw_grid = false;

	public:                // 생성자
		Game2D()
		{}

		/* 제목(title), 해상도(width, height), 풀스크린 사용여부, 어느 모니터에 출력할지
이렇게 4가지 설정 가능 */
		Game2D(const std::string& _title, const int& _width, const int& _height,
			const bool & use_full_screen = false, const int & display_ix = 0);

		~Game2D();

		Game2D & init(const std::string& _title, const int& _width, const int& _height,
			const bool & use_full_screen = false, const int & display_ix = 0);

		초기화 하는 과정에서의 에러 출력 (거의 볼 일 X)
		void reportErrorAndExit(const std::string& function_name, const std::string& message);

		bool isKeyPressed(const int& key); 
		bool isKeyReleased(const int & key);
		bool isKeyPressedAndReleased(const int& key); // 사용자가 키를 눌렀다가 뗐는지를 확인하는 함수

		bool isMouseButtonPressed(const int& mbtn);
		bool isMouseButtonReleased(const int& mbtn);
		bool isMouseButtonPressedAndReleased(const int& mbtn);

		vec2 getCursorPos(const bool& screen_coordinates = true);

		float getTimeStep(); // 한 프레임 당 시간이 얼마나 지났는지 측정해주는 함수

		void drawGrid();

		/*run과 update 아주 중요!*/ 
 		void run(); // Game2D.cpp 에 바디 있음

		virtual void update()  //가상함수인 이유 -> 꼭 오버라이딩 해서 사용하라는 의미 ! 
		{
      // 예시
			  // draw
			  // play sould
			  // physics update
			  // etc.
		}
	};
}
```

***📜Game2D.cpp***에서 `void Game2D::run()` 함수 부분 설명
- `while`부분이 제일 중요하다. 프로그램의 메인 Loop가 된다.

```cpp
Game2D.cpp 中

void Game2D::run()
	{
		if (glfw_window == nullptr)
			init("This is my digital canvas!", 1280, 960, false); // initialize with default setting

		// 게임의 메인 루프
		while (!glfwWindowShouldClose(glfw_window))// main loop
		{
			// 1. ESC 누르면 종료 
			if (isKeyPressed(GLFW_KEY_ESCAPE)) {
				std::cout << "ESC key ends main loop" << std::endl;
				break;
			}
			
			// 2. 타이머 start
			timer.start();

			// 3. 렌더링 시작 전 전처리
			glfwMakeContextCurrent(glfw_window);
			glClearColor(1, 1, 1, 1);			 // while background
			glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
			glMatrixMode(GL_MODELVIEW);
			glPushMatrix();

			// 4. 격자 그리기
			drawGrid();

			// 5. ⭐update 함수 호출⭐
			update();	// the major worker function

			// 6. 렌더링 완료하고 마무리
			glPopMatrix();
			// post draw
			glfwSwapBuffers(glfw_window); // double buffering
			//glfwSetInputMode(glfw_window, GLFW_STICKY_KEYS, GLFW_FALSE); // not working 
			glfwPollEvents();

			//const double dt = timer.stopAndGetElapsedMilli();

			//Debugging
			//std::cout << dt << std::endl;

			//if (dt < spf) // to prevent too high fps
			//{
			//	const auto time_to_sleep = static_cast<int>((spf - dt) * 1000.0f);
			//	std::this_thread::sleep_for(std::chrono::milliseconds(time_to_sleep));
			//	
			//	//Debugging
			//	//std::cout << "sleep " << time_to_sleep << std::endl;
			//}
		}

		glfwTerminate();
	}
```

***

## 내가 실습한 코드

### 1. 빈 화면만 출력하기

```cpp
#include "Game2D.h"
#include "PrimitivesGallery.h"
#include "TankExample.h"
#include "FaceExample.h"
#include "WalkingPerson.h"
#include "SolarSystem.h"

namespace jm
{
	class RotatingStarExample : public Game2D
	{
	public:
		void update() override  // Game2D의 update 함수 오버라이딩
		{

		}
	};
}

int main(void)
{
	jm::RotatingStarExample().run();
	
	return 0;
}
```

### 2. 풀 스크린의 빈 스크린 출력하기

```cpp
#include "Game2D.h"
#include "PrimitivesGallery.h"
#include "TankExample.h"
#include "FaceExample.h"
#include "WalkingPerson.h"
#include "SolarSystem.h"

namespace jm
{
	class RotatingStarExample : public Game2D
	{
	public:
		void update() override  // Game2D의 update 함수 오버라이딩
		{

		}
	};
}

int main(void)
{
	/* 생성자 네번째 인수를 true로 바꿔 풀스크린 
	창 이름은 "This is my digital canvas!" */
	jm::RotatingStarExample().init("This is my digital canvas!", 1280, 960, true).run();
	
	return 0;
}
```

### 3. 별 그려보기

`DrawFunction.h`의 `drawFilledStar` 함수 사용

```cpp
#include "Game2D.h"
#include "PrimitivesGallery.h"
#include "TankExample.h"
#include "FaceExample.h"
#include "WalkingPerson.h"
#include "SolarSystem.h"

namespace jm
{
	class RotatingStarExample : public Game2D
	{
	public:
		void update() override  // Game2D의 update 함수 오버라이딩
		{
				drawFilledStar(Colors::gold, 0.4f, 0.25f);
				// 별의 바깥쪽 원의 반지름이 0.4f라는 의미, 별 안쪽의 원의 반지름이 0.25f라는 의미
		}
	};
}

int main(void)
{

	jm::RotatingStarExample().init("This is my digital canvas!", 1280, 960, false).run();
	
	return 0;
}
```

### 4. 회전하는 별 그려보기 (시간 개념 필요)

```cpp
#include "Game2D.h"
#include "PrimitivesGallery.h"
#include "TankExample.h"
#include "FaceExample.h"
#include "WalkingPerson.h"
#include "SolarSystem.h"

namespace jm
{
	class RotatingStarExample : public Game2D
	{
		float time = 0.0f;  // 시간 0.0에서 시작
	public:
		void update() override // Game2D의 update 함수 오버라이딩
		{
				rotate(time * 180.0f); // 1초에 반바퀴 돌게끔

				drawFilledStar(Colors::gold, 0.4f, 0.25f);
				
				time += this->getTimeStep(); // 시간이 흘러야 함
		}
	};
}

int main(void)
{

	jm::RotatingStarExample().init("This is my digital canvas!", 1280, 960, false).run();
	
	return 0;
}
```

***
<br>

    🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
    언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}